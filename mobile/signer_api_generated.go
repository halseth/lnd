// Code generated by falafel 0.7. DO NOT EDIT.
// source: signrpc/signer.proto

// +build signrpc

package lndmobile

import (
	"context"

	"github.com/golang/protobuf/proto"

	"github.com/lightningnetwork/lnd/lnrpc/signrpc"
)

// getSignerClient returns a client connection to the server listening
// on lis.
func getSignerClient() (signrpc.SignerClient, func(), error) {
	clientConn, closeConn, err := getLightningLisConn()
	if err != nil {
		return nil, nil, err
	}
	client := signrpc.NewSignerClient(clientConn)
	return client, closeConn, nil
}

// SignOutputRaw is a method that can be used to generated a signature for a
// set of inputs/outputs to a transaction. Each request specifies details
// concerning how the outputs should be signed, which keys they should be
// signed with, and also any optional tweaks. The return value is a fixed
// 64-byte signature (the same format as we use on the wire in Lightning).
//
// If we are  unable to sign using the specified keys, then an error will be
// returned.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SignOutputRaw(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.SignReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*signrpc.SignReq)
			return client.SignOutputRaw(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ComputeInputScript generates a complete InputIndex for the passed
// transaction with the signature as defined within the passed SignDescriptor.
// This method should be capable of generating the proper input script for
// both regular p2wkh output and p2wkh outputs nested within a regular p2sh
// output.
//
// Note that when using this method to sign inputs belonging to the wallet,
// the only items of the SignDescriptor that need to be populated are pkScript
// in the TxOut field, the value in that same field, and finally the input
// index.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ComputeInputScript(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.SignReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*signrpc.SignReq)
			return client.ComputeInputScript(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SignMessage signs a message with the key specified in the key locator. The
// returned signature is fixed-size LN wire format encoded.
//
// The main difference to SignMessage in the main RPC is that a specific key is
// used to sign the message instead of the node identity private key.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SignMessage(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.SignMessageReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*signrpc.SignMessageReq)
			return client.SignMessage(ctx, r)
		},
	}
	s.start(msg, callback)
}

// VerifyMessage verifies a signature over a message using the public key
// provided. The signature must be fixed-size LN wire format encoded.
//
// The main difference to VerifyMessage in the main RPC is that the public key
// used to sign the message does not have to be a node known to the network.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func VerifyMessage(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.VerifyMessageReq{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*signrpc.VerifyMessageReq)
			return client.VerifyMessage(ctx, r)
		},
	}
	s.start(msg, callback)
}

// DeriveSharedKey returns a shared secret key by performing Diffie-Hellman key
// derivation between the ephemeral public key in the request and the node's
// key specified in the key_loc parameter (or the node's identity private key
// if no key locator is specified):
// P_shared = privKeyNode * ephemeralPubkey
// The resulting shared public key is serialized in the compressed format and
// hashed with sha256, resulting in the final key length of 256bit.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func DeriveSharedKey(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &signrpc.SharedKeyRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getSignerClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*signrpc.SharedKeyRequest)
			return client.DeriveSharedKey(ctx, r)
		},
	}
	s.start(msg, callback)
}
