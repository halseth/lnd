// Code generated by falafel 0.7. DO NOT EDIT.
// source: routerrpc/router.proto

// +build routerrpc

package lndmobile

import (
	"context"

	"github.com/golang/protobuf/proto"

	"github.com/lightningnetwork/lnd/lnrpc/routerrpc"
)

// getRouterClient returns a client connection to the server listening
// on lis.
func getRouterClient() (routerrpc.RouterClient, func(), error) {
	clientConn, closeConn, err := getLightningLisConn()
	if err != nil {
		return nil, nil, err
	}
	client := routerrpc.NewRouterClient(clientConn)
	return client, closeConn, nil
}

// SendPayment attempts to route a payment described by the passed
// PaymentRequest to the final destination. The call returns a stream of
// payment status updates.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func SendPayment(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.SendPaymentRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.SendPaymentRequest)
			stream, err := client.SendPayment(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// TrackPayment returns an update stream for the payment identified by the
// payment hash.
//
// NOTE: This method produces a stream of responses, and the receive stream can
// be called zero or more times. After EOF error is returned, no more responses
// will be produced.
func TrackPayment(msg []byte, rStream RecvStream) {
	s := &readStreamHandler{
		newProto: func() proto.Message {
			return &routerrpc.TrackPaymentRequest{}
		},
		recvStream: func(ctx context.Context,
			req proto.Message) (*receiver, func(), error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, nil, err
			}

			r := req.(*routerrpc.TrackPaymentRequest)
			stream, err := client.TrackPayment(ctx, r)
			if err != nil {
				closeClient()
				return nil, nil, err
			}
			return &receiver{
				recv: func() (proto.Message, error) {
					return stream.Recv()
				},
			}, closeClient, nil
		},
	}
	s.start(msg, rStream)
}

// EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
// may cost to send an HTLC to the target end destination.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func EstimateRouteFee(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.RouteFeeRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.RouteFeeRequest)
			return client.EstimateRouteFee(ctx, r)
		},
	}
	s.start(msg, callback)
}

// SendToRoute attempts to make a payment via the specified route. This method
// differs from SendPayment in that it allows users to specify a full route
// manually. This can be used for things like rebalancing, and atomic swaps.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func SendToRoute(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.SendToRouteRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.SendToRouteRequest)
			return client.SendToRoute(ctx, r)
		},
	}
	s.start(msg, callback)
}

// ResetMissionControl clears all mission control state and starts with a clean
// slate.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func ResetMissionControl(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.ResetMissionControlRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.ResetMissionControlRequest)
			return client.ResetMissionControl(ctx, r)
		},
	}
	s.start(msg, callback)
}

// QueryMissionControl exposes the internal mission control state to callers.
// It is a development feature.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func QueryMissionControl(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.QueryMissionControlRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.QueryMissionControlRequest)
			return client.QueryMissionControl(ctx, r)
		},
	}
	s.start(msg, callback)
}

// QueryProbability returns the current success probability estimate for a
// given node pair and amount.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func QueryProbability(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.QueryProbabilityRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.QueryProbabilityRequest)
			return client.QueryProbability(ctx, r)
		},
	}
	s.start(msg, callback)
}

// BuildRoute builds a fully specified route based on a list of hop public
// keys. It retrieves the relevant channel policies from the graph in order to
// calculate the correct fees and time locks.
//
// NOTE: This method produces a single result or error, and the callback will
// be called only once.
func BuildRoute(msg []byte, callback Callback) {
	s := &syncHandler{
		newProto: func() proto.Message {
			return &routerrpc.BuildRouteRequest{}
		},
		getSync: func(ctx context.Context,
			req proto.Message) (proto.Message, error) {

			// Get the gRPC client.
			client, closeClient, err := getRouterClient()
			if err != nil {
				return nil, err
			}
			defer closeClient()

			r := req.(*routerrpc.BuildRouteRequest)
			return client.BuildRoute(ctx, r)
		},
	}
	s.start(msg, callback)
}
